{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Operation overview","text":""},{"location":"#transmission-process","title":"Transmission process","text":"<p>Project simulates transsmission process (with focus on 5G polar code) in following steps:</p> <ol> <li>Message source</li> <li>Polar encoding</li> <li>BPSK modulation</li> <li>Sending through AWGN channel</li> <li>Successive Cancelation decoding</li> </ol> <pre><code>---\ntitle: Transmission process\n---\n\nflowchart LR\n  Source e1@==&gt; E[Polar Encoder]\n  E e2@==&gt; M[BPSK Modulator]\n  M e3@==&gt; C[AWGN Channel]\n  C e4@==&gt; D[SC Decoder]\n\n  e1@{ animate: true }\n  e2@{ animate: true }\n  e3@{ animate: true }\n  e4@{ animate: true }\n</code></pre>"},{"location":"results/","title":"Results","text":"<p>\\(BER(E_b/N_0) \\ [dB]\\)</p>"},{"location":"pages/reference/ber_test/","title":"BER test","text":""},{"location":"pages/reference/ber_test/#src.BER_test.BER","title":"<code>BER(input, output)</code>","text":"<p>Calculating BER (Bit Error Rate) for two seqences of bits.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>NDArray[uint8]</code> <p>Sent bits (not yet affected by noise in channel).</p> required <code>output</code> <code>NDArray[uint8]</code> <p>Received bits after transmission.</p> required <p>Returns:</p> Type Description <code>float</code> <p>BER value.</p> Source code in <code>src\\BER_test.py</code> <pre><code>def BER(input: NDArray[np.uint8], output: NDArray[np.uint8]) -&gt; float:\n    \"\"\"\n    Calculating BER (Bit Error Rate) for two seqences of bits.\n\n    Parameters\n    ----------\n    input : NDArray[np.uint8]\n        Sent bits (not yet affected by noise in channel).\n    output : NDArray[np.uint8]\n        Received bits after transmission.\n\n    Returns\n    -------\n    float\n        BER value.\n    \"\"\"\n\n    return (input != output).sum()/input.size\n</code></pre>"},{"location":"pages/reference/ber_test/#src.BER_test.avg_BER","title":"<code>avg_BER(EbN0dB_values, K_values)</code>","text":"<p>Calculating average BER values for different Eb/N0 [dB].</p> <p>Parameters:</p> Name Type Description Default <code>EbN0dB_values</code> <code>NDArray[float64]</code> <p>Array with various Eb/N0 [dB] values.</p> required <code>K_values</code> <code>NDArray[uint16]</code> <p>Array with various sizes of messages.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Values of average BER for different Eb/N0 [dB] values.</p> Source code in <code>src\\BER_test.py</code> <pre><code>def avg_BER(EbN0dB_values: NDArray[np.float64], K_values: NDArray[np.uint16]) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Calculating average BER values for different Eb/N0 [dB].\n\n    Parameters\n    ----------\n    EbN0dB_values : NDArray[np.float64]\n        Array with various Eb/N0 [dB] values. \n    K_values : NDArray[np.uint16]\n        Array with various sizes of messages. \n\n    Returns\n    -------\n    NDArray[np.float64]\n        Values of average BER for different Eb/N0 [dB] values.\n    \"\"\"\n\n    path_1 = \"tables\\\\fixed_interleaving_pattern_table.txt\"\n    path_2 = \"tables\\\\polar_sequence_and_its_corresponding_reliability.txt\"\n\n    pi_max_il = load_fixed_interleaving_pattern_table(path_1)\n    Q = load_polar_sequence_and_reliability_table(path_2)\n\n    ### actors\n    encoder = Encoder(pi_max_il, Q)\n    modulator = Modulator()\n    channel = Channel(\"gwn\")\n    decoder = Decoder(Q)\n    ###\n\n    avg_ber_arr = np.zeros(EbN0dB_values.size, dtype=np.float64)\n    for msg in generate_messages(K_values):\n        code_word = encoder.encode(msg, E=msg.size) # encoding\n        bpsk_out = modulator.bpsk(code_word) # BPSK modulating \n\n        for i, EbN0dB in enumerate(EbN0dB_values):     \n            channel_out = channel.send_through(mod_seq=bpsk_out, EbN0dB=EbN0dB, K=msg.size) # adding white noise\n            _, decoded_seq = decoder.decode(r=channel_out, K=msg.size) # decoding\n\n            avg_ber_arr[i] += BER(msg, decoded_seq)/K_values.size # calculating average BER for next Eb/N0 [dB] values\n\n    return avg_ber_arr\n</code></pre>"},{"location":"pages/reference/ber_test/#src.BER_test.generate_messages","title":"<code>generate_messages(K_values)</code>","text":"<p>Generates random messages of sizes provided by K_values parameter.</p> <p>Parameters:</p> Name Type Description Default <code>K_values</code> <code>NDArray[uint16]</code> <p>Sizes of messages arrays that will be generated.</p> required <p>Yields:</p> Type Description <code>Generator[NDArray[uint16], None, None]</code> <p>Messages of sizes defined in K_values parameter.</p> Source code in <code>src\\BER_test.py</code> <pre><code>def generate_messages(K_values: NDArray[np.uint16]) -&gt; Generator[NDArray[np.uint16], None, None]:\n    \"\"\"\n    Generates random messages of sizes provided by K_values parameter.\n\n    Parameters\n    ----------\n    K_values : NDArray[np.uint16]\n        Sizes of messages arrays that will be generated.\n\n    Yields\n    ------\n    Generator[NDArray[np.uint16], None, None]\n        Messages of sizes defined in K_values parameter.\n    \"\"\"\n\n    for K in K_values:\n        yield np.random.randint(low=0, high=2, size=K, dtype=np.uint8)\n</code></pre>"},{"location":"pages/reference/channel/","title":"Channel","text":"<p>               Bases: <code>object</code></p> <p>Class that is representation of the channel.</p> <p>Attributes:</p> Name Type Description <code>noise_type</code> <code>str</code> <p>Type of noise in channel.</p> <code>_noise_method</code> <code>Callable[[float, int, int], NDArray[float64]]</code> <p>Method responible for generating noise.</p> <p>Methods:</p> Name Description <code>gwn</code> <p>Function returns samples of gaussian white noise.</p> <code>send_through</code> <p>Function retunrs samples of signal after channel noise.</p> Source code in <code>src\\transmission_simulation.py</code> <pre><code>class Channel(object):\n    \"\"\"\n    Class that is representation of the channel.\n\n    Attributes\n    ----------\n    noise_type : str\n        Type of noise in channel.\n    _noise_method: Callable[[float, int, int], NDArray[np.float64]]\n        Method responible for generating noise.\n    Methods\n    -------\n    gwn()\n        Function returns samples of gaussian white noise.\n    send_through()\n        Function retunrs samples of signal after channel noise.\n    \"\"\"\n\n    def __init__(self, noise_type: str):\n        \"\"\"\"\"\"\n        self.noise_type = noise_type\n        noise_method = getattr(self, noise_type)\n        if not isinstance(noise_method, (FunctionType, MethodType)):\n            raise ValueError(f\"There is no such method '{noise_type}' in Channel class.\")\n        self._noise_method = noise_method\n\n\n    def gwn(self, EbN0dB: float, K: int, N: int) -&gt; NDArray[np.float64]:\n        \"\"\"\"\"\"\n        N0Eb = 10 ** (-EbN0dB/10)\n        std_dev = sqrt(0.5 * N/K * N0Eb)\n\n        return np.random.randn(N) * std_dev\n\n\n    def send_through(self, mod_seq: NDArray[np.int8], EbN0dB: float, K: int) -&gt; NDArray[np.float64]:\n        \"\"\"\"\"\"\n        N = mod_seq.size\n        return mod_seq + self._noise_method(EbN0dB, K, N)\n</code></pre>"},{"location":"pages/reference/channel/#src.transmission_simulation.Channel.__init__","title":"<code>__init__(noise_type)</code>","text":"Source code in <code>src\\transmission_simulation.py</code> <pre><code>def __init__(self, noise_type: str):\n    \"\"\"\"\"\"\n    self.noise_type = noise_type\n    noise_method = getattr(self, noise_type)\n    if not isinstance(noise_method, (FunctionType, MethodType)):\n        raise ValueError(f\"There is no such method '{noise_type}' in Channel class.\")\n    self._noise_method = noise_method\n</code></pre>"},{"location":"pages/reference/channel/#src.transmission_simulation.Channel.gwn","title":"<code>gwn(EbN0dB, K, N)</code>","text":"Source code in <code>src\\transmission_simulation.py</code> <pre><code>def gwn(self, EbN0dB: float, K: int, N: int) -&gt; NDArray[np.float64]:\n    \"\"\"\"\"\"\n    N0Eb = 10 ** (-EbN0dB/10)\n    std_dev = sqrt(0.5 * N/K * N0Eb)\n\n    return np.random.randn(N) * std_dev\n</code></pre>"},{"location":"pages/reference/channel/#src.transmission_simulation.Channel.send_through","title":"<code>send_through(mod_seq, EbN0dB, K)</code>","text":"Source code in <code>src\\transmission_simulation.py</code> <pre><code>def send_through(self, mod_seq: NDArray[np.int8], EbN0dB: float, K: int) -&gt; NDArray[np.float64]:\n    \"\"\"\"\"\"\n    N = mod_seq.size\n    return mod_seq + self._noise_method(EbN0dB, K, N)\n</code></pre>"},{"location":"pages/reference/decoder/","title":"Decoder","text":"<p>               Bases: <code>object</code></p> <p>Class representing basic SC (Successive Cancelation) decoder.</p> <p>...</p> <p>Attributes:</p> Name Type Description <code>Q</code> <code>NDArray[uint16]</code> <p>Vector where indexes represent realiabilities and values represent polar sequence.</p> <p>Methods:</p> Name Description <code>decode</code> <p>Method for decoding code words.</p> Source code in <code>src\\decoder\\sc_decoder.py</code> <pre><code>class Decoder(object):\n    \"\"\"\n    Class representing basic SC (Successive Cancelation) decoder.\n\n    ...\n    Attributes\n    ----------\n    Q : NDArray[np.uint16]\n        Vector where indexes represent realiabilities and values represent polar sequence.\n\n    Methods\n    -------\n    decode()\n        Method for decoding code words.\n    \"\"\"\n\n    def __init__(self, Q: NDArray[np.uint16]):\n        \"\"\"\n        Parameters\n        ----------\n        Q : NDArray[np.uint16]\n            Vector where indexes represent realiabilities and values represent polar sequence.\n        \"\"\"\n        self.Q = Q\n\n    @staticmethod\n    def createDecodingTree(root: DecodingTreeNode, depth: int) -&gt; DecodingTreeNode:\n        \"\"\"\"\"\"\n        if depth == 0:\n            return root\n\n        root.left_child = DecodingTreeNode()\n        root.right_child = DecodingTreeNode()\n        depth -= 1\n\n        Decoder.createDecodingTree(root.left_child, depth)\n        Decoder.createDecodingTree(root.right_child, depth)\n\n        return root\n\n    @staticmethod\n    def combine(v1: NDArray[np.uint8], v2: NDArray[np.uint8]) -&gt; NDArray[np.uint8]:\n        \"\"\"\"\"\"\n        sum_mod2 = np.mod(v1 + v2, 2).astype(np.uint8)\n        v2_uint8 = v2.astype(np.uint8)\n\n        return np.concatenate([sum_mod2, v2_uint8])\n\n\n\n    def decode(self, r: NDArray[np.float64], K: int) -&gt; Tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n        \"\"\"\n        Function for decoding code word (polar code).\n\n        Parameters\n        ----------\n        r : NDArray[np.float64]\n            Encoded message (code word) after modulation (and channel influence).\n        K : int\n            Number of information bits.\n\n        Returns\n        -------\n        NDArray[np.uint8]\n            Decoded bit sequence.\n\n        \"\"\"\n\n        N = r.size\n        Q = self.Q[self.Q &lt; N]\n        frozen_bits_idxes = Q[:N-K]\n        message_bits_idxes = Q[N-K:]\n\n        def decodingTreeTraverse(root: DecodingTreeNode, L: NDArray[np.float64], bit_idx: int) -&gt; Tuple[NDArray[np.uint8], NDArray[np.uint8], int]:\n            \"\"\"\"\"\"\n            if root.left_child is None and root.right_child is None:\n                if bit_idx in frozen_bits_idxes:\n                    u = 0\n                else:\n                    u = 0 if L[0] &gt;= 0 else 1\n\n                return np.array([u]), np.array([u]), bit_idx + 1\n\n            assert root.left_child and root.right_child\n\n            left_L = root.f(L)\n            u1, v1, bit_idx = decodingTreeTraverse(root.left_child, left_L, bit_idx)\n            right_L = root.g(L, u1)\n            u2, v2, bit_idx = decodingTreeTraverse(root.right_child, right_L, bit_idx)\n\n            return Decoder.combine(u1, u2), np.concatenate([v1, v2]), bit_idx\n\n\n        root = Decoder.createDecodingTree(root=DecodingTreeNode(), depth=int(log2(r.size)))\n        recreated_r, decoded_seq, _ = decodingTreeTraverse(root, r, 0)\n\n        return recreated_r, decoded_seq[message_bits_idxes]\n</code></pre>"},{"location":"pages/reference/decoder/#src.decoder.sc_decoder.Decoder.__init__","title":"<code>__init__(Q)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>Q</code> <code>NDArray[uint16]</code> <p>Vector where indexes represent realiabilities and values represent polar sequence.</p> required Source code in <code>src\\decoder\\sc_decoder.py</code> <pre><code>def __init__(self, Q: NDArray[np.uint16]):\n    \"\"\"\n    Parameters\n    ----------\n    Q : NDArray[np.uint16]\n        Vector where indexes represent realiabilities and values represent polar sequence.\n    \"\"\"\n    self.Q = Q\n</code></pre>"},{"location":"pages/reference/decoder/#src.decoder.sc_decoder.Decoder.combine","title":"<code>combine(v1, v2)</code>  <code>staticmethod</code>","text":"Source code in <code>src\\decoder\\sc_decoder.py</code> <pre><code>@staticmethod\ndef combine(v1: NDArray[np.uint8], v2: NDArray[np.uint8]) -&gt; NDArray[np.uint8]:\n    \"\"\"\"\"\"\n    sum_mod2 = np.mod(v1 + v2, 2).astype(np.uint8)\n    v2_uint8 = v2.astype(np.uint8)\n\n    return np.concatenate([sum_mod2, v2_uint8])\n</code></pre>"},{"location":"pages/reference/decoder/#src.decoder.sc_decoder.Decoder.createDecodingTree","title":"<code>createDecodingTree(root, depth)</code>  <code>staticmethod</code>","text":"Source code in <code>src\\decoder\\sc_decoder.py</code> <pre><code>@staticmethod\ndef createDecodingTree(root: DecodingTreeNode, depth: int) -&gt; DecodingTreeNode:\n    \"\"\"\"\"\"\n    if depth == 0:\n        return root\n\n    root.left_child = DecodingTreeNode()\n    root.right_child = DecodingTreeNode()\n    depth -= 1\n\n    Decoder.createDecodingTree(root.left_child, depth)\n    Decoder.createDecodingTree(root.right_child, depth)\n\n    return root\n</code></pre>"},{"location":"pages/reference/decoder/#src.decoder.sc_decoder.Decoder.decode","title":"<code>decode(r, K)</code>","text":"<p>Function for decoding code word (polar code).</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>NDArray[float64]</code> <p>Encoded message (code word) after modulation (and channel influence).</p> required <code>K</code> <code>int</code> <p>Number of information bits.</p> required <p>Returns:</p> Type Description <code>NDArray[uint8]</code> <p>Decoded bit sequence.</p> Source code in <code>src\\decoder\\sc_decoder.py</code> <pre><code>def decode(self, r: NDArray[np.float64], K: int) -&gt; Tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n    \"\"\"\n    Function for decoding code word (polar code).\n\n    Parameters\n    ----------\n    r : NDArray[np.float64]\n        Encoded message (code word) after modulation (and channel influence).\n    K : int\n        Number of information bits.\n\n    Returns\n    -------\n    NDArray[np.uint8]\n        Decoded bit sequence.\n\n    \"\"\"\n\n    N = r.size\n    Q = self.Q[self.Q &lt; N]\n    frozen_bits_idxes = Q[:N-K]\n    message_bits_idxes = Q[N-K:]\n\n    def decodingTreeTraverse(root: DecodingTreeNode, L: NDArray[np.float64], bit_idx: int) -&gt; Tuple[NDArray[np.uint8], NDArray[np.uint8], int]:\n        \"\"\"\"\"\"\n        if root.left_child is None and root.right_child is None:\n            if bit_idx in frozen_bits_idxes:\n                u = 0\n            else:\n                u = 0 if L[0] &gt;= 0 else 1\n\n            return np.array([u]), np.array([u]), bit_idx + 1\n\n        assert root.left_child and root.right_child\n\n        left_L = root.f(L)\n        u1, v1, bit_idx = decodingTreeTraverse(root.left_child, left_L, bit_idx)\n        right_L = root.g(L, u1)\n        u2, v2, bit_idx = decodingTreeTraverse(root.right_child, right_L, bit_idx)\n\n        return Decoder.combine(u1, u2), np.concatenate([v1, v2]), bit_idx\n\n\n    root = Decoder.createDecodingTree(root=DecodingTreeNode(), depth=int(log2(r.size)))\n    recreated_r, decoded_seq, _ = decodingTreeTraverse(root, r, 0)\n\n    return recreated_r, decoded_seq[message_bits_idxes]\n</code></pre>"},{"location":"pages/reference/decoding_tree_node/","title":"DecodingTreeNode","text":"<p>               Bases: <code>object</code></p> Source code in <code>src\\decoder\\sc_decoding_tree.py</code> <pre><code>class DecodingTreeNode(object):\n    \"\"\"\"\"\"\n    def __init__(self, left_child: \"DecodingTreeNode | None\" = None, right_child: \"DecodingTreeNode | None\" = None):\n        \"\"\"\"\"\"\n        self.left_child = left_child\n        self.right_child = right_child\n\n    def f(self, L: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        \"\"\"\"\"\"\n        sgn = lambda x: copysign(1, x) # signum function\n        new_L = np.zeros(L.size//2, dtype=L.dtype)\n\n        i = 0\n        for beliefs in zip(L[:L.size//2], L[L.size//2:]): \n            belief = sgn(beliefs[0]) * sgn(beliefs[1]) * min(abs(beliefs[0]), abs(beliefs[1])) \n            new_L[i] = belief\n            i += 1\n\n        return new_L \n\n    def g(self, L: NDArray[np.float64], c: NDArray[np.uint8]) -&gt; NDArray[np.float64]:\n        \"\"\"\"\"\"\n        new_L = np.zeros(L.size//2, dtype=L.dtype)\n\n        i = 0\n        for beliefs in zip(L[:L.size//2], L[L.size//2:]):\n            belief = beliefs[1] + beliefs[0] if c[i] == 0 else beliefs[1] - beliefs[0]\n            new_L[i] = belief\n            i += 1\n\n        return new_L\n</code></pre>"},{"location":"pages/reference/decoding_tree_node/#src.decoder.sc_decoding_tree.DecodingTreeNode.__init__","title":"<code>__init__(left_child=None, right_child=None)</code>","text":"Source code in <code>src\\decoder\\sc_decoding_tree.py</code> <pre><code>def __init__(self, left_child: \"DecodingTreeNode | None\" = None, right_child: \"DecodingTreeNode | None\" = None):\n    \"\"\"\"\"\"\n    self.left_child = left_child\n    self.right_child = right_child\n</code></pre>"},{"location":"pages/reference/decoding_tree_node/#src.decoder.sc_decoding_tree.DecodingTreeNode.f","title":"<code>f(L)</code>","text":"Source code in <code>src\\decoder\\sc_decoding_tree.py</code> <pre><code>def f(self, L: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n    \"\"\"\"\"\"\n    sgn = lambda x: copysign(1, x) # signum function\n    new_L = np.zeros(L.size//2, dtype=L.dtype)\n\n    i = 0\n    for beliefs in zip(L[:L.size//2], L[L.size//2:]): \n        belief = sgn(beliefs[0]) * sgn(beliefs[1]) * min(abs(beliefs[0]), abs(beliefs[1])) \n        new_L[i] = belief\n        i += 1\n\n    return new_L \n</code></pre>"},{"location":"pages/reference/decoding_tree_node/#src.decoder.sc_decoding_tree.DecodingTreeNode.g","title":"<code>g(L, c)</code>","text":"Source code in <code>src\\decoder\\sc_decoding_tree.py</code> <pre><code>def g(self, L: NDArray[np.float64], c: NDArray[np.uint8]) -&gt; NDArray[np.float64]:\n    \"\"\"\"\"\"\n    new_L = np.zeros(L.size//2, dtype=L.dtype)\n\n    i = 0\n    for beliefs in zip(L[:L.size//2], L[L.size//2:]):\n        belief = beliefs[1] + beliefs[0] if c[i] == 0 else beliefs[1] - beliefs[0]\n        new_L[i] = belief\n        i += 1\n\n    return new_L\n</code></pre>"},{"location":"pages/reference/encoder/","title":"Encoder","text":"<p>Class representing encoder.</p> <p>Attributes:</p> Name Type Description <code>pi_max_il</code> <code>NDArray[uint8]</code> <p>Vector representing fixed interleaving pattern table.</p> <code>Q</code> <code>NDArray[uint16]</code> <p>Vector where indexes represent realiabilities and values represent polar sequence.</p> <p>Methods:</p> Name Description <code>determine_n</code> <p>The purpose of this function is to determine n.</p> <code>interleave</code> <p>Function is doing interleaving to distribute errors on the output of decoder and increase efficiency of coding.</p> <code>encode</code> <p>Function for encoding using polar code, function does not anticipate the presence of parity bits in message.</p> Source code in <code>src\\encoder.py</code> <pre><code>class Encoder:\n    \"\"\"\n    Class representing encoder.\n\n    Attributes\n    ----------\n    pi_max_il : NDArray[np.uint8]\n        Vector representing fixed interleaving pattern table.\n    Q : NDArray[np.uint16]\n        Vector where indexes represent realiabilities and values represent polar sequence.\n\n    Methods\n    -------\n    determine_n(K, E, n_max)\n        The purpose of this function is to determine n.\n    interleave(K, i_il, pi_max_il)\n        Function is doing interleaving to distribute errors on the output of decoder and increase efficiency of coding.\n    encode(msg)\n        Function for encoding using polar code, function does not anticipate the presence of parity bits in message.\n    \"\"\"\n\n    def __init__(self, pi_max_il: NDArray[np.uint8], Q: NDArray[np.uint16]):\n        \"\"\"\n        Inicjalizacja enkodera.\n\n        Parameters\n        ----------\n        pi_max_il : NDArray[np.uint8]\n            Vector representing fixed interleaving pattern table.\n\n        Q : NDArray[np.uint16]\n            Vector where indexes represent reliabilities and values represent polar sequence.\n        \"\"\"\n\n        self.pi_max_il = pi_max_il\n        self.Q = Q\n\n\n    def determine_n(self, K: int, E: int, n_max: int) -&gt; int:\n        \"\"\" \n        The bit sequence input for a given code block to channel coding is denoted by c[0], c[1], c[2], c[3], ..., c[K-1] where K is the\n        number of bits to encode. After encoding the bits are denoted by d[0], d[1], d[2], ..., d[N-1], where N = 2^n and the purpose of \n        this function is to determine n.\n\n        Parameters\n        ----------\n        K : int\n            Number of bits in input bit sequence.\n        E : int\n            Rate matching output length. It is stated by the higher layers (MAC, scheduler) before channel encoding - in the transmission planning phase.\n        n_max : int\n            In polar encoding is the maximum exponent of 2 for the encoded block length N. It limits how large a single block can be. In 5G NR for user data: n_max = 11, for control info: n_max = 9.\n\n        Returns\n        -------\n        int\n            The predcited n.\n        \"\"\"\n\n        if E &lt; K:\n            raise ValueError(f\"E = {E} is less than K = {K}: too few bits to hold the information\")\n        if E &gt; 2**n_max:\n            raise ValueError(f\"E = {E} exceeds maximum block length 2**{n_max} = {2**n_max}\")\n\n        if ( E &lt;= (9/8) * pow(2, ceil(log2(E))-1) ) and ( (K / E) &lt; 9/16 ):\n            n1 = ceil(log2(E)) - 1\n        else:\n            n1 = ceil(log2(E))\n\n        R_min = 1/8\n        n2 = ceil(log2(K / R_min))\n\n        n_min = 5 # default is 5 \n        n = max(min(n1, n2, n_max), n_min)\n\n        return n\n\n\n    def interleave(self, K: int, i_il: bool, pi_max_il: NDArray[np.uint8]) -&gt; NDArray[np.uint8]:\n        \"\"\"\n        Function is doing interleaving to distribute errors on the output of decoder and increase efficiency of coding.\n\n        Parameters\n        ----------\n        K : int\n            Number of bits in input bit sequence.\n        i_il : bool\n            When set to False no interleaving is occuring.\n        pi_max_il : NDArray[np.uint8]\n            Representing fixed interleaving pattern (table) stated in 5G standard.\n\n        Returns\n        -------\n        NDArray[np.uint8]\n            The created interleaving pattern.\n        \"\"\"\n\n        K_max_il = pi_max_il.size     # number of entries in table of fixed interleaving pattern\n        pi = np.empty(K, dtype=np.uint8)\n\n        if not i_il:\n            pi = np.arange(K, dtype=np.uint8)\n        else:\n            k = 0\n            for m in range(K_max_il):\n                if pi_max_il[m] &gt;= K_max_il - K:\n                    pi[k] = pi_max_il[m] - (K_max_il - K)\n                    k += 1\n\n        return pi\n\n\n    def encode(self, msg: NDArray[np.uint8], E: int) -&gt; NDArray[np.uint8]:\n        \"\"\"\n        Function for encoding using polar code, function does not anticipate the presence of parity bits in message.\n\n        Parameters\n        ----------\n        msg : NDArray[np.uint8]\n            Message bits sequence to be encoded.\n        E : int\n            Rate matching output length. It is stated by the higher layers (MAC, scheduler) before channel encoding - in the transmission planning phase.\n\n        Returns\n        -------\n        NDArray[np.uint8]\n            Encoded bits sequence.\n        \"\"\"\n\n        K = msg.size\n        n = self.determine_n(K=K, E=E, n_max=9)\n        N = pow(2, n)\n\n        # permutation_pattern = self.interleave(K=K, i_il=False, pi_max_il=self.pi_max_il)\n        Q = self.Q[self.Q &lt; N]\n        #frozen_bits_idxes = Q[:N-K]\n        message_bits_idxes = Q[N-K:]\n        u = np.zeros(N, dtype=np.uint8)\n        u[message_bits_idxes] = msg\n\n        k = 1\n        while k &lt; N:\n            for i in range(0, N, 2*k):\n                u[i:i+k] = np.mod(u[i:i+k] + u[i+k:i+2*k], 2)\n            k *= 2\n\n        return u\n</code></pre>"},{"location":"pages/reference/encoder/#src.encoder.Encoder.__init__","title":"<code>__init__(pi_max_il, Q)</code>","text":"<p>Inicjalizacja enkodera.</p> <p>Parameters:</p> Name Type Description Default <code>pi_max_il</code> <code>NDArray[uint8]</code> <p>Vector representing fixed interleaving pattern table.</p> required <code>Q</code> <code>NDArray[uint16]</code> <p>Vector where indexes represent reliabilities and values represent polar sequence.</p> required Source code in <code>src\\encoder.py</code> <pre><code>def __init__(self, pi_max_il: NDArray[np.uint8], Q: NDArray[np.uint16]):\n    \"\"\"\n    Inicjalizacja enkodera.\n\n    Parameters\n    ----------\n    pi_max_il : NDArray[np.uint8]\n        Vector representing fixed interleaving pattern table.\n\n    Q : NDArray[np.uint16]\n        Vector where indexes represent reliabilities and values represent polar sequence.\n    \"\"\"\n\n    self.pi_max_il = pi_max_il\n    self.Q = Q\n</code></pre>"},{"location":"pages/reference/encoder/#src.encoder.Encoder.determine_n","title":"<code>determine_n(K, E, n_max)</code>","text":"<p>The bit sequence input for a given code block to channel coding is denoted by c[0], c[1], c[2], c[3], ..., c[K-1] where K is the number of bits to encode. After encoding the bits are denoted by d[0], d[1], d[2], ..., d[N-1], where N = 2^n and the purpose of  this function is to determine n.</p> <p>Parameters:</p> Name Type Description Default <code>K</code> <code>int</code> <p>Number of bits in input bit sequence.</p> required <code>E</code> <code>int</code> <p>Rate matching output length. It is stated by the higher layers (MAC, scheduler) before channel encoding - in the transmission planning phase.</p> required <code>n_max</code> <code>int</code> <p>In polar encoding is the maximum exponent of 2 for the encoded block length N. It limits how large a single block can be. In 5G NR for user data: n_max = 11, for control info: n_max = 9.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The predcited n.</p> Source code in <code>src\\encoder.py</code> <pre><code>def determine_n(self, K: int, E: int, n_max: int) -&gt; int:\n    \"\"\" \n    The bit sequence input for a given code block to channel coding is denoted by c[0], c[1], c[2], c[3], ..., c[K-1] where K is the\n    number of bits to encode. After encoding the bits are denoted by d[0], d[1], d[2], ..., d[N-1], where N = 2^n and the purpose of \n    this function is to determine n.\n\n    Parameters\n    ----------\n    K : int\n        Number of bits in input bit sequence.\n    E : int\n        Rate matching output length. It is stated by the higher layers (MAC, scheduler) before channel encoding - in the transmission planning phase.\n    n_max : int\n        In polar encoding is the maximum exponent of 2 for the encoded block length N. It limits how large a single block can be. In 5G NR for user data: n_max = 11, for control info: n_max = 9.\n\n    Returns\n    -------\n    int\n        The predcited n.\n    \"\"\"\n\n    if E &lt; K:\n        raise ValueError(f\"E = {E} is less than K = {K}: too few bits to hold the information\")\n    if E &gt; 2**n_max:\n        raise ValueError(f\"E = {E} exceeds maximum block length 2**{n_max} = {2**n_max}\")\n\n    if ( E &lt;= (9/8) * pow(2, ceil(log2(E))-1) ) and ( (K / E) &lt; 9/16 ):\n        n1 = ceil(log2(E)) - 1\n    else:\n        n1 = ceil(log2(E))\n\n    R_min = 1/8\n    n2 = ceil(log2(K / R_min))\n\n    n_min = 5 # default is 5 \n    n = max(min(n1, n2, n_max), n_min)\n\n    return n\n</code></pre>"},{"location":"pages/reference/encoder/#src.encoder.Encoder.encode","title":"<code>encode(msg, E)</code>","text":"<p>Function for encoding using polar code, function does not anticipate the presence of parity bits in message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>NDArray[uint8]</code> <p>Message bits sequence to be encoded.</p> required <code>E</code> <code>int</code> <p>Rate matching output length. It is stated by the higher layers (MAC, scheduler) before channel encoding - in the transmission planning phase.</p> required <p>Returns:</p> Type Description <code>NDArray[uint8]</code> <p>Encoded bits sequence.</p> Source code in <code>src\\encoder.py</code> <pre><code>def encode(self, msg: NDArray[np.uint8], E: int) -&gt; NDArray[np.uint8]:\n    \"\"\"\n    Function for encoding using polar code, function does not anticipate the presence of parity bits in message.\n\n    Parameters\n    ----------\n    msg : NDArray[np.uint8]\n        Message bits sequence to be encoded.\n    E : int\n        Rate matching output length. It is stated by the higher layers (MAC, scheduler) before channel encoding - in the transmission planning phase.\n\n    Returns\n    -------\n    NDArray[np.uint8]\n        Encoded bits sequence.\n    \"\"\"\n\n    K = msg.size\n    n = self.determine_n(K=K, E=E, n_max=9)\n    N = pow(2, n)\n\n    # permutation_pattern = self.interleave(K=K, i_il=False, pi_max_il=self.pi_max_il)\n    Q = self.Q[self.Q &lt; N]\n    #frozen_bits_idxes = Q[:N-K]\n    message_bits_idxes = Q[N-K:]\n    u = np.zeros(N, dtype=np.uint8)\n    u[message_bits_idxes] = msg\n\n    k = 1\n    while k &lt; N:\n        for i in range(0, N, 2*k):\n            u[i:i+k] = np.mod(u[i:i+k] + u[i+k:i+2*k], 2)\n        k *= 2\n\n    return u\n</code></pre>"},{"location":"pages/reference/encoder/#src.encoder.Encoder.interleave","title":"<code>interleave(K, i_il, pi_max_il)</code>","text":"<p>Function is doing interleaving to distribute errors on the output of decoder and increase efficiency of coding.</p> <p>Parameters:</p> Name Type Description Default <code>K</code> <code>int</code> <p>Number of bits in input bit sequence.</p> required <code>i_il</code> <code>bool</code> <p>When set to False no interleaving is occuring.</p> required <code>pi_max_il</code> <code>NDArray[uint8]</code> <p>Representing fixed interleaving pattern (table) stated in 5G standard.</p> required <p>Returns:</p> Type Description <code>NDArray[uint8]</code> <p>The created interleaving pattern.</p> Source code in <code>src\\encoder.py</code> <pre><code>def interleave(self, K: int, i_il: bool, pi_max_il: NDArray[np.uint8]) -&gt; NDArray[np.uint8]:\n    \"\"\"\n    Function is doing interleaving to distribute errors on the output of decoder and increase efficiency of coding.\n\n    Parameters\n    ----------\n    K : int\n        Number of bits in input bit sequence.\n    i_il : bool\n        When set to False no interleaving is occuring.\n    pi_max_il : NDArray[np.uint8]\n        Representing fixed interleaving pattern (table) stated in 5G standard.\n\n    Returns\n    -------\n    NDArray[np.uint8]\n        The created interleaving pattern.\n    \"\"\"\n\n    K_max_il = pi_max_il.size     # number of entries in table of fixed interleaving pattern\n    pi = np.empty(K, dtype=np.uint8)\n\n    if not i_il:\n        pi = np.arange(K, dtype=np.uint8)\n    else:\n        k = 0\n        for m in range(K_max_il):\n            if pi_max_il[m] &gt;= K_max_il - K:\n                pi[k] = pi_max_il[m] - (K_max_il - K)\n                k += 1\n\n    return pi\n</code></pre>"},{"location":"pages/reference/modulator/","title":"Modulator","text":"<p>               Bases: <code>object</code></p> <p>Class representing modualtor.</p> <p>Attributes:</p> Name Type Description <code>...</code> <p>Methods:</p> Name Description <code>bpsk</code> <p>The purpose of this method is to modulate bit sequence using BPSK.</p> Source code in <code>src\\modulator.py</code> <pre><code>class Modulator(object):\n    \"\"\"\n    Class representing modualtor.\n\n    Attributes\n    ----------\n    ...\n\n    Methods\n    -------\n    bpsk(bit_seq)\n        The purpose of this method is to modulate bit sequence using BPSK.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def bpsk(self, bit_seq: NDArray[np.uint8]) -&gt; NDArray[np.int8]:\n        \"\"\"\n        Performs BPSK modulation.\n\n        Parameters\n        ----------\n        bit_seq : NDArray[np.uint8]\n            Input bit seqence.\n\n        Returns\n        -------\n        bpsk_out_seq : NDArray[np.int8]\n            Seqence after BPSK modulation (channel input signal).\n        \"\"\"\n\n        size = bit_seq.size\n        bpsk_out_seq = np.zeros(size, dtype=np.int8)\n\n        for i in range(size):\n            bpsk_out_seq[i] = 1 if bit_seq[i] == 0 else -1\n\n        return bpsk_out_seq\n</code></pre>"},{"location":"pages/reference/modulator/#src.modulator.Modulator.bpsk","title":"<code>bpsk(bit_seq)</code>","text":"<p>Performs BPSK modulation.</p> <p>Parameters:</p> Name Type Description Default <code>bit_seq</code> <code>NDArray[uint8]</code> <p>Input bit seqence.</p> required <p>Returns:</p> Name Type Description <code>bpsk_out_seq</code> <code>NDArray[int8]</code> <p>Seqence after BPSK modulation (channel input signal).</p> Source code in <code>src\\modulator.py</code> <pre><code>def bpsk(self, bit_seq: NDArray[np.uint8]) -&gt; NDArray[np.int8]:\n    \"\"\"\n    Performs BPSK modulation.\n\n    Parameters\n    ----------\n    bit_seq : NDArray[np.uint8]\n        Input bit seqence.\n\n    Returns\n    -------\n    bpsk_out_seq : NDArray[np.int8]\n        Seqence after BPSK modulation (channel input signal).\n    \"\"\"\n\n    size = bit_seq.size\n    bpsk_out_seq = np.zeros(size, dtype=np.int8)\n\n    for i in range(size):\n        bpsk_out_seq[i] = 1 if bit_seq[i] == 0 else -1\n\n    return bpsk_out_seq\n</code></pre>"},{"location":"pages/theory/add_noise/","title":"Adding gaussian white noise","text":""},{"location":"pages/theory/add_noise/#noise-parameters","title":"Noise parameters","text":"<p>Symbols info</p> <ul> <li>\\(E_b/N_0\\) \u2014 the ratio of bit energy to noise power density, expressed in dB</li> <li>\\(N\\) \u2014 number of noise samples generated</li> <li>\\(K\\) \u2014 number of bits modulated simultaneously (e.g. in M-ary modulation)</li> </ul> <p>Converting from dB to linear scale:</p> \\[ \\frac{N_0}{E_b} = 10^{-\\frac{E_b/N_0\\,[\\mathrm{dB}]}{10}}. \\]"},{"location":"pages/theory/add_noise/#standard-deviation-of-noise","title":"Standard deviation of noise","text":"<p>By definition of Gaussian white noise, the noise energy per bit is \\(\\tfrac{N_0}{2}\\). For \\(K\\) bits and \\(N\\) samples, the standard deviation \\(\\sigma\\) is:</p> \\[ \\sigma = \\sqrt{\\frac{1}{2}\\,\\frac{N}{K}\\,\\frac{N_0}{E_b}} = \\sqrt{\\frac{1}{2}\\,\\frac{N}{K}\\,10^{-\\frac{E_b/N_0\\,\\mathrm{[dB]}}{10}}}. \\]"},{"location":"pages/theory/add_noise/#generating-awgn-in-python","title":"Generating AWGN in Python","text":"<pre><code>def gwn(self, EbN0dB: float, K: int, N: int) -&gt; NDArray[np.float64]:\n    # Converting E_b/N_0 from dB to linear scale\n    N0Eb = 10 ** (-EbN0dB/10)\n    # Calculating standard deviation\n    std_dev = sqrt(0.5 * N/K * N0Eb)\n    # Generating N samples of white gaussian noise\n    return np.random.randn(N) * std_dev\n</code></pre>"},{"location":"pages/theory/bpsk_modulation/","title":"BPSK modulation","text":"<p>In BPSK (Binary Phase Shift Keying), each bit \\((u_j \\in \\{0,1\\}\\) is mapped to a symbol.</p> \\[ r_j = 1 - 2\\,u_j \\quad\\Longrightarrow\\quad r_j = \\begin{cases} +1, &amp; \\text{if } u_j = 0,\\\\ -1, &amp; \\text{if } u_j = 1. \\end{cases} \\] <p>The entire BPSK signal is written as:</p> \\[ s(t) = \\sum_{j=1}^{N} r_j \\,\\cos\\bigl(2\\pi f_c\\,t\\bigr)\\, \\Pi\\!\\Bigl(\\frac{t - jT_r}{T_r}\\Bigr), \\] <p>where the rectangular function \\(\\Pi(z)\\) is defined as:</p> \\[ \\Pi(z) = \\begin{cases} 1, &amp; 0 \\le z &lt; 1,\\\\ 0, &amp; \\text{otherwise}. \\end{cases} \\] <p>Symbols info</p> <ul> <li>\\(\\vec{u}\\) \u2013 input bit sequence, where \\(u_j \\in \\{0,1\\}\\)</li> <li>\\(\\vec{r}\\) \u2013 BPSK symbols, where \\(r_j \\in \\{+1,-1\\}\\) </li> <li>\\(f_c\\) \u2013 carrier frequency  </li> <li>\\(T_r\\) \u2013 bit duration  </li> <li>\\(N\\) \u2013 number of bits</li> </ul>"},{"location":"pages/theory/encoding_process/","title":"Encoding process","text":""},{"location":"pages/theory/encoding_process/#example-encding-for-n-2","title":"Example encding for N = 2","text":"<p>1. Polar transform \\(\\mathbf{G}_2\\)</p> \\[ \\mathbf{G}_2 \\;=\\;  \\begin{bmatrix} 1 &amp; 0 \\\\[6pt] 1 &amp; 1 \\end{bmatrix} \\] <p>2. \\(\\vec{u}\\) is a input vector for polar encoding (channel encoding). It is a result of source encoding</p> \\[ \\vec{u} = \\begin{pmatrix} u_{1} &amp; u_{2} \\end{pmatrix} \\] <p>3. \\(\\vec{x}\\) is a vector that represents code word (it is \\(\\vec{u}\\) after encoding)</p> \\[ \\vec{x} =  \\vec{u} \\times \\mathbf{G}_2 \\] \\[ \\vec{x} =  \\begin{pmatrix}  u_{1} &amp; u_{2}  \\end{pmatrix} \\times \\begin{bmatrix} 1 &amp; 0 \\\\[6pt] 1 &amp; 1 \\end{bmatrix} = \\begin{pmatrix}  u_{1} + u_{2} &amp; u_{2}  \\end{pmatrix} \\] <p>4. Encoding tree</p> <pre><code>%%{init: {\"flowchart\": {\"htmlLabels\": true}, \"securityLevel\": \"loose\"}}%%\nflowchart BT\n  B((d=1, i=0)) e1@--&gt; A((d=0, i=0))\n  C((d=1, i=1)) e2@--&gt; A\n\n  e1@{ animate : true }\n  e2@{ animate : true }\n</code></pre> <p>Nodes info</p> <p>d - means depth, i - ID of node on given depth</p> <ul> <li>(d=0, i=0) \\(\\quad\\vec{u^{(2)}} = \\begin{pmatrix} u_{1} + u_{2} &amp; u_{2} \\end{pmatrix}\\)</li> <li>(d=1, i=0) \\(\\quad u_1\\)</li> <li>(d=1, i=1) \\(\\quad u_2\\)</li> </ul>"},{"location":"pages/theory/encoding_process/#example-encoding-for-n-4","title":"Example encoding for N = 4","text":"<p>1. Polar transform \\(\\mathbf{G}_4\\)</p> <p>Warning</p> <p>\\(\\otimes\\;\\) is a Kronecker product of two matrices.</p> \\[ \\mathbf{G}_4 =  \\mathbf{G}_2 \\otimes  \\mathbf{G}_2 \\] \\[ \\mathbf{G}_4 \\;=\\; \\begin{bmatrix} 1 &amp; 0\\\\[6pt] 1 &amp; 1 \\end{bmatrix} \\otimes \\begin{bmatrix} 1 &amp; 0\\\\[6pt] 1 &amp; 1 \\end{bmatrix} \\] \\[ \\mathbf{G}_4 \\;=\\;  \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\[6pt] 1 &amp; 1 &amp; 0 &amp; 0\\\\[6pt] 1 &amp; 0 &amp; 1 &amp; 0\\\\[6pt] 1 &amp; 1 &amp; 1 &amp; 1 \\end{bmatrix} \\] <p>2. \\(\\vec{u}\\) is a input vector for polar encoding (channel encoding). It is a result of source encoding</p> \\[ \\vec{u} = \\begin{pmatrix} u_{1} &amp; u_{2} &amp; u_3 &amp; u_4 \\end{pmatrix} \\] <p>3. \\(\\vec{x}\\) is a vector that represents code word (it is \\(\\vec{u}\\) after encoding)</p> \\[ \\vec{x} =  \\vec{u} \\times \\mathbf{G}_4 \\] \\[ \\vec{x} =  \\begin{pmatrix}  u_{1} &amp; u_{2} &amp; u_{3} &amp; u_{4} \\end{pmatrix} \\times \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\[6pt] 1 &amp; 1 &amp; 0 &amp; 0\\\\[6pt] 1 &amp; 0 &amp; 1 &amp; 0\\\\[6pt] 1 &amp; 1 &amp; 1 &amp; 1 \\end{bmatrix} = \\begin{pmatrix}  u_1 + u_2 + u_3 + u_4 &amp; u_2 + u_4 &amp; u_3 + u_4 &amp; u_4 \\end{pmatrix} \\] <p>4. Encoding tree</p> <pre><code>%%{init: {\"flowchart\": {\"htmlLabels\": true}, \"securityLevel\": \"loose\"}}%%\nflowchart BT\n  B((d=1, i=0)) e1@--&gt; A((d=0, i=0))\n  C((d=1, i=1)) e2@--&gt; A\n  D((d=2, i=0)) e3@--&gt; B\n  E((d=2, i=1)) e4@--&gt; B\n  F((d=2, i=2)) e5@--&gt; C\n  G((d=2, i=3)) e6@--&gt; C\n\n  e1@{ animate : true }\n  e2@{ animate : true }\n  e3@{ animate : true }\n  e4@{ animate : true }\n  e5@{ animate : true }\n  e6@{ animate : true }\n\n</code></pre> <p>Nodes info</p> <p>d - depth level, i - ID of node on given depth</p> <ul> <li>(d=0, i=0) \\(\\quad\\vec{u^{(4)}} = \\begin{pmatrix} \\vec{u_{1}^{(2)}} + \\vec{u_{2}^{(2)}} &amp; \\vec{u_{2}^{(2)}} \\end{pmatrix} = \\begin{pmatrix} u_1 + u_2 + u_3 + u_4 &amp; u_2 + u_4 &amp; u_3 + u_4 &amp; u_4 \\end{pmatrix}\\)</li> <li>(d=1, i=0) \\(\\quad \\vec{u_1^{(2)}} = \\begin{pmatrix} u_1 + u_2 &amp; u_2 \\end{pmatrix}\\) </li> <li>(d=1, i=1) \\(\\quad \\vec{u_2^{(2)}} = \\begin{pmatrix} u_3 + u_4 &amp; u_4 \\end{pmatrix}\\)</li> <li>(d=2, i=0) \\(\\quad u_1\\)</li> <li>(d=2, i=1) \\(\\quad u_2\\)</li> <li>(d=2, i=2) \\(\\quad u_3\\)</li> <li>(d=2, i=3) \\(\\quad u_4\\)</li> </ul>"},{"location":"pages/theory/encoding_process/#general-case","title":"General case","text":"<p>1. Polar transform \\(\\mathbf{G}_N\\)</p> <p>Warning</p> <p>\\(\\otimes\\;\\) is a Kronecker product of two matrices.</p> \\[ \\mathbf{G}_N \\;=\\; \\begin{bmatrix} 1 &amp; 0\\\\[6pt] 1 &amp; 1 \\end{bmatrix} ^{\\otimes \\ n}  \\] <p>Symnols info</p> <ul> <li>\\(N\\) - code word length (\\(N = 2^n\\))</li> <li>\\(K\\) - number of information bits</li> <li>\\(n\\) - tree depth (5G uses \\(n &lt;= 10\\)) </li> </ul> <p>2. Reliability sequence</p> <p>Every reliability sequence include numbers of one-bit channels which are arranged in order from least to most reliable.</p> <p>Examples of relaibility sequences:</p> \\[ \\begin{aligned} N &amp;= 32 \\quad \\begin{pmatrix}  1 &amp; 2 &amp; 3 &amp; 5 &amp; 9 &amp; 17 &amp; 4 &amp; 6 &amp; 10 &amp; 7 &amp; 18 &amp; 11 &amp; 19 &amp; 13 &amp; 21 &amp; 25 &amp; 8 &amp; 12 &amp; 20 &amp; 14 &amp; 15 &amp; 22 &amp; 27 &amp; 26 &amp; 23 &amp; 29 &amp; 16 &amp; 24 &amp; 28 &amp; 30 &amp; 31 &amp; 32 \\end{pmatrix} \\\\ \\\\ N &amp;= 16 \\quad \\begin{pmatrix}  1 &amp; 2 &amp; 3 &amp; 5 &amp; 9 &amp; 4 &amp; 6 &amp; 10 &amp; 7 &amp; 11 &amp; 13 &amp; 8 &amp; 12 &amp; 14 &amp; 16 \\end{pmatrix} \\\\ \\\\ N &amp;= 8 \\quad \\begin{pmatrix}  1 &amp; 2 &amp; 3 &amp; 5 &amp; 4 &amp; 6 &amp; 7 &amp; 8  \\end{pmatrix} \\end{aligned} \\] <p>In 5G standard reliability sequence (table) is defined for \\(N = 1024\\). If we are using values of \\(N\\) smaller than \\(1024\\) e.g. \\(N = 8\\) for \\(K = 5\\) we have to shorten size of our sequence defined in standard. We do this by deleting from original sequence (\\(N = 1024\\)) every numbers of channnels that are smaller than \\(N = 8\\). So for \\(N = 8\\) we are deleting every channels numbers that are not included in the range \\(\\left[ 1, 8 \\right]\\)</p> <p>3. Frozen bits</p> <p>We are choosing \\(N - K\\) least reliable bit channels (its numbers will be indexes of frozen bits in code word) from reliability sequence that we have created in previous point. Bits with these indexes are set to \\(0\\). On the rest of the bits we are writing information bits from original input sequence (message) of lenght \\(K\\). Created in this way sequence of lenght \\(N\\) is fed to the encoder input (as the leafs of the encoding tree).</p> <p>4. Example of creating vector \\(\\vec{u}\\) according to 5g standard for code (8, 4)</p> <p>Code parameters</p> <p>\\(N = 8 \\qquad K = 4 \\qquad N - K = 4\\)</p> <p>Symbols info</p> <ul> <li>\\(f\\) - frozen bit</li> <li>\\(m_i\\) - message bit</li> </ul> \\[ \\begin{aligned} \\text{reliability sequence} &amp;=  \\begin{pmatrix} 1 &amp; 2 &amp; 3 &amp; 5 &amp; 4 &amp; 6 &amp; 7 &amp; 8 \\end{pmatrix} \\\\ \\\\ \\text{frozen bits} &amp;=  \\begin{pmatrix} 1 &amp; 2 &amp; 3 &amp; 5 \\end{pmatrix} \\\\ \\\\ \\text{message bits} &amp;=  \\begin{pmatrix} 4 &amp; 6 &amp; 7 &amp; 8 \\end{pmatrix} \\\\ \\\\ \\vec{u} &amp;= \\begin{pmatrix} f &amp; f &amp; f &amp; m_1 &amp; f &amp; m_2 &amp; m_3 &amp; m_4 \\end{pmatrix} =  \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; m_1 &amp; 0 &amp; m_2 &amp; m_3 &amp; m_4 \\end{pmatrix} \\end{aligned} \\]"}]}